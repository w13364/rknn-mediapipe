// // Init RKNN model
// ret = rknn_init(&ctx, model, model_len, 0, NULL);
// // Get Model Input Output Number
// rknn_input_output_num io_num;
// ret = rknn_query(ctx, RKNN_QUERY_IN_OUT_NUM, &io_num, sizeof(io_num));
// // Get Model Input Info
// rknn_tensor_attr input_attrs[io_num.n_input];
// memset(input_attrs, 0, sizeof(input_attrs));
// for (int i = 0; i < io_num.n_input; i++)
// {
// input_attrs[i].index = i;
// ret = rknn_query(ctx, RKNN_QUERY_INPUT_ATTR, &(input_attrs[i]), sizeof(rknn_tensor_attr));
// }
// // Get Model Output Info
// rknn_tensor_attr output_attrs[io_num.n_output];
// memset(output_attrs, 0, sizeof(output_attrs));
// for (int i = 0; i < io_num.n_output; i++)
// {
// output_attrs[i].index = i;
// ret = rknn_query(ctx, RKNN_QUERY_OUTPUT_ATTR, &(output_attrs[i]), sizeof(rknn_tensor_attr));
// }
// rknn_input inputs[io_num.n_input];
// rknn_output outputs[io_num.n_output];
// memset(inputs, 0, sizeof(inputs));
// memset(outputs, 0, sizeof(outputs));
// // Pre-process
// // Read Image
// image_buffer_t src_image;
// memset(&src_image, 0, sizeof(image_buffer_t));
// ret = read_image(image_path, &src_image);




// // Set Input Data
// inputs[0].index = 0;
// inputs[0].type = RKNN_TENSOR_UINT8;
// inputs[0].fmt = RKNN_TENSOR_NHWC;
// inputs[0].size = src_image.size;
// inputs[0].buf = src_image.virt_addr;
// ret = rknn_inputs_set(rknn_ctx, io_num.n_input, inputs);
// // Run
// ret = rknn_run(rknn_ctx, nullptr);
// // Get Output Data
// ret = rknn_outputs_get(rknn_ctx, io_num.n_output, outputs, NULL);
// // Post-process
// post_process(outputs, results);
// // Release RKNN Output
// rknn_outputs_release(rknn_ctx, io_num.n_output, outputs);

// if (rknn_ctx != 0)
// {
// rknn_destroy(rknn_ctx);
// }






ret = rknn_init(&ctx, model_data, model_data_size, 0, NULL);
//no need to hold the model in the buffer. Get some memory back
free(model_data);

if (ret < 0) {
    printf("rknn_init error ret=%d\n", ret);
    return -1;
}

rknn_sdk_version version;
ret = rknn_query(ctx, RKNN_QUERY_SDK_VERSION, &version, sizeof(rknn_sdk_version));
if (ret < 0) {
    printf("rknn_init error ret=%d\n", ret);
    return -1;
}
printf("sdk version: %s driver version: %s\n", version.api_version, version.drv_version);

rknn_input_output_num io_num;
ret = rknn_query(ctx, RKNN_QUERY_IN_OUT_NUM, &io_num, sizeof(io_num));
if (ret < 0) {
    printf("rknn_init error ret=%d\n", ret);
    return -1;
}
printf("\nmodel input num: %d\n", io_num.n_input);
rknn_tensor_attr input_attrs[io_num.n_input];
memset(input_attrs, 0, sizeof(input_attrs));
for(uint32_t i = 0; i < io_num.n_input; i++) {
    input_attrs[i].index = i;
    ret                  = rknn_query(ctx, RKNN_QUERY_INPUT_ATTR, &(input_attrs[i]), sizeof(rknn_tensor_attr));
    if (ret < 0) {
        printf("rknn_init error ret=%d\n", ret);
        return -1;
    }
    dump_tensor_attr(&(input_attrs[i]));
}

printf("\nmodel output num: %d\n", io_num.n_output);
rknn_tensor_attr output_attrs[io_num.n_output];
memset(output_attrs, 0, sizeof(output_attrs));
for (uint32_t i = 0; i < io_num.n_output; i++) {
    output_attrs[i].index = i;
    ret                   = rknn_query(ctx, RKNN_QUERY_OUTPUT_ATTR, &(output_attrs[i]), sizeof(rknn_tensor_attr));
    dump_tensor_attr(&(output_attrs[i]));
}

int channel = 3;
int width   = 0;
int height  = 0;
if (input_attrs[0].fmt == RKNN_TENSOR_NCHW) {
    printf("\nmodel input is NCHW\n");
    channel = input_attrs[0].dims[1];
    height  = input_attrs[0].dims[2];
    width   = input_attrs[0].dims[3];
}
else {
    printf("\nmodel input is NHWC\n");
    height  = input_attrs[0].dims[1];
    width   = input_attrs[0].dims[2];
    channel = input_attrs[0].dims[3];
}

printf("model input height=%d, width=%d, channel=%d\n\n", height, width, channel);

rknn_input inputs[1];
memset(inputs, 0, sizeof(inputs));
inputs[0].index        = 0;
inputs[0].type         = RKNN_TENSOR_UINT8;
inputs[0].size         = width * height * channel;
inputs[0].fmt          = RKNN_TENSOR_NHWC;
inputs[0].pass_through = 0;



    // You may not need resize when src resulotion equals to dst resulotion
    cv::Mat orig_img;
    cv::Mat img;
    cv::Mat resized_img;

    printf("Start grabbing, press ESC on Live window to terminated...\n");
    while(1){

        orig_img=cv::imread(imagepath, 1);
        if(orig_img.empty()) {
            printf("Error grabbing\n");
            break;
        }

        Tbegin = std::chrono::steady_clock::now();

        cv::cvtColor(orig_img, img, cv::COLOR_BGR2RGB);
        img_width  = img.cols;
        img_height = img.rows;

        //check sizes
        if (img_width != width || img_height != height) {
            cv::resize(img,resized_img,cv::Size(width,height));
            inputs[0].buf = (void*)resized_img.data;
        } else {
            inputs[0].buf = (void*)img.data;
        }

        rknn_inputs_set(ctx, io_num.n_input, inputs);

        rknn_output outputs[io_num.n_output];
        memset(outputs, 0, sizeof(outputs));
        for (uint32_t i = 0; i < io_num.n_output; i++) {
            outputs[i].index = i;
            outputs[i].want_float = 0;
        }

        rknn_run(ctx, NULL);
        rknn_outputs_get(ctx, io_num.n_output, outputs, NULL);

        // post process
        float scale_w = (float)width / img_width;
        float scale_h = (float)height / img_height;